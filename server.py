import http.server
import socketserver
import socket
import os
import signal
import sys

# Define the port for the server
PORT = 8000

class CORSRequestHandler(http.server.SimpleHTTPRequestHandler):
    """
    This is a custom request handler that inherits from Python's built-in
    SimpleHTTPRequestHandler. We customize it to add modern web features
    required by applications using WebAssembly, Web Workers, and SharedArrayBuffer.
    """

    def end_headers(self):
        """
        This method is called to send the HTTP headers. We override it to add
        our custom headers before the default ones are sent.
        """
        # Set the Cross-Origin-Opener-Policy (COOP) header.
        # 'same-origin' is required to create a secure context for features
        # like SharedArrayBuffer, which is crucial for high-performance
        # communication between the main thread and Web Workers.
        self.send_header('Cross-Origin-Opener-Policy', 'same-origin')

        # Set the Cross-Origin-Embedder-Policy (COEP) header.
        # 'require-corp' (corp = Cross-Origin Resource Policy) ensures that
        # all resources loaded by the document are from the same origin or
        # explicitly marked as loadable from another origin. This, along with
        # COOP, prevents certain cross-origin attacks and is a prerequisite
        # for enabling SharedArrayBuffer.
        self.send_header('Cross-Origin-Embedder-Policy', 'require-corp')
        
        # Call the original end_headers method to finish sending headers.
        super().end_headers()

# Add the MIME type for WebAssembly files. This is essential for browsers
# to correctly interpret and execute the .wasm module.
CORSRequestHandler.extensions_map['.wasm'] = 'application/wasm'
CORSRequestHandler.extensions_map['.js'] = 'application/javascript'


def get_local_ip():
    """
    A helper function to find the local IP address of the machine.
    This is useful for accessing the server from other devices on the same network.
    """
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        # This doesn't need to be a reachable address.
        # It's a trick to get the OS to reveal the primary network interface IP.
        s.connect(('10.255.255.255', 1))
        IP = s.getsockname()[0]
    except Exception:
        IP = '127.0.0.1' # Fallback to localhost if unable to find the local IP
    finally:
        s.close()
    return IP

# --- Main Execution Block ---
if __name__ == "__main__":
    # Change the current working directory to the directory where this script is located.
    # This ensures that the server serves files from the correct project root,
    # regardless of where the python command is executed from.
    script_dir = os.path.dirname(os.path.abspath(__file__))
    os.chdir(script_dir)

    # Using socketserver.ThreadingTCPServer for a multi-threaded, non-blocking server.
    httpd = socketserver.ThreadingTCPServer(("", PORT), CORSRequestHandler)

    # --- Graceful Shutdown Handler ---
    def signal_handler(sig, frame):
        """A custom handler for the SIGINT signal (generated by Ctrl+C)."""
        print('\nShutting down server gracefully...')
        # The httpd.shutdown() call will stop the serve_forever() loop.
        # It needs to be called from a different thread, which the signal
        # handler effectively provides.
        httpd.shutdown()
        # The server_close() method is called automatically by the __exit__
        # method of the TCPServer context manager when the 'with' block is exited.
        sys.exit(0)

    # Register the custom signal handler for Ctrl+C interrupts.
    signal.signal(signal.SIGINT, signal_handler)

    try:
        local_ip = get_local_ip()
        
        # Provide clear, user-friendly URLs for access.
        print("\n---------------------------------------------------")
        print("  HexLife Local Development Server")
        print("---------------------------------------------------")
        print(f"  Serving files from: {script_dir}")
        print("\n  Access the application at one of these URLs:")
        print(f"  - On this machine: http://localhost:{PORT}")
        print(f"  - On other devices in your network: http://{local_ip}:{PORT}")
        print("\n  Press Ctrl+C to stop the server.")
        print("---------------------------------------------------\n")
        
        # Start the server and keep it running until shutdown() is called.
        httpd.serve_forever()

    except Exception as e:
        print(f"Server could not be started: {e}")
        # This typically happens if the port is already in use.
    finally:
        # Ensure the server is closed properly, even if serve_forever()
        # exits unexpectedly (which it shouldn't, but this is good practice).
        httpd.server_close()
